"""CLI command to control the Database."""

from __future__ import annotations

import csv
import random
from asyncio import run as aiorun
from pathlib import Path
from typing import TYPE_CHECKING, Annotated, Optional

import typer
from alembic import command
from alembic.config import Config
from faker import Faker
from fastapi import HTTPException
from rich import print as rprint
from sqlalchemy.exc import SQLAlchemyError

from app.database.db import async_session
from app.managers.user import ErrorMessages, UserManager
from app.models.enums import RoleType

if TYPE_CHECKING:  # pragma: no cover
    from sqlalchemy.ext.asyncio import AsyncSession

app = typer.Typer(no_args_is_help=True, rich_markup_mode="rich")

ALEMBIC_CFG = Config("alembic_scripting.ini")
DONE_MSG = "[green]Done!"


@app.command()
def init(
    force: Optional[bool] = typer.Option(
        False,
        "--force",
        "-f",
        prompt=(
            "Warning! This deletes all data in the database. Are you sure?"
        ),
        help="Do not ask for confirmation.",
    ),
) -> None:
    """Re-Initialise the database using Alembic.

    This will create the database if it does not exist, and run all migrations.
    If the database already exists, it will be dropped and recreated.
    """
    if force:
        rprint("\nInitialising Database ... ", end="")

        command.downgrade(ALEMBIC_CFG, "base")
        command.upgrade(ALEMBIC_CFG, "head")
        rprint(DONE_MSG)
    else:
        rprint("[cyan]Operation Cancelled.")


@app.command()
def drop(
    force: Optional[bool] = typer.Option(
        False,
        "--force",
        "-f",
        prompt=(
            "Warning! This deletes all data in the database. Are you sure?"
        ),
        help="Do not ask for confirmation.",
    ),
) -> None:
    """Drop all tables and reset the Database.

    This will delete all data from your Database!.
    """
    if force:
        rprint("\nDropping all tables ... ", end="")

        command.downgrade(ALEMBIC_CFG, "base")
        rprint(DONE_MSG)
    else:
        rprint("[cyan]Operation Cancelled.")


@app.command()
def upgrade() -> None:
    """Apply the latest Database Migrations."""
    rprint("\nUpgrading Database ... ", end="")

    command.upgrade(ALEMBIC_CFG, "head")
    rprint(DONE_MSG)


@app.command()
def revision(
    message: str = typer.Option(
        ...,
        "--message",
        "-m",
        prompt=("Enter the commit message for the revision"),
        help="Provide a message for this commit.",
    ),
) -> None:
    """Create a new revision.

    The revision will be created in the `alembic/versions` directory, and is
    autogenerated based on the current state of the database.
    """
    rprint()
    command.revision(ALEMBIC_CFG, message=message, autogenerate=True)
    command.upgrade(ALEMBIC_CFG, "head")


def calc_admin_count(count: int) -> tuple[int, int]:
    """Calculate the number of admin users to create."""
    if count < 1:
        rprint("[red]Error: count must be greater than 0")
        raise typer.Exit(1)

    # Calculate number of admins (1 per 5 users, max 3)
    # Special case: if count=1, create a regular user not an admin
    if count == 1:
        num_admins = 0
        num_regular_users = 1
    else:
        num_admins = min(count // 5 + (1 if count % 5 > 0 else 0), 3)
        num_regular_users = count - num_admins

    return num_admins, num_regular_users


@app.command()
def populate(
    count: int = typer.Option(
        5,
        "--count",
        "-c",
        help="Number of users to create",
    ),
) -> None:
    """Populate the database with random test users.

    This will create the specified number of users with random data. At least 1
    admin will be created for every 5 users, up to a maximum of 3 admins.
    """
    num_admins, num_regular_users = calc_admin_count(count)

    rprint(
        f"\nCreating {num_regular_users} regular users "
        f"and {num_admins} admins..."
    )

    # Run the async function to populate the database
    aiorun(_populate_db(num_regular_users, num_admins))

    rprint(DONE_MSG)


async def _create_single_user(
    fake: Faker,
    session: AsyncSession,
    max_retries: int = 5,
    *,
    is_admin: bool = False,
) -> bool:
    """Create a single user with retry logic for duplicate emails."""
    retries = 0

    # List of common email domains
    domains = [
        "gmail.com",
        "yahoo.com",
        "hotmail.com",
        "outlook.com",
        "icloud.com",
        "example.com",
        "company.com",
        "fastmail.com",
        "protonmail.com",
        "mail.com",
        "aol.com",
        "zoho.com",
    ]

    # Email patterns to use with first and last names
    # {f} = first name,
    # {l} = last name,
    # {fi} = first initial,
    # {li} = last initial
    email_patterns = [
        "{f}.{l}@{d}",  # john.doe@gmail.com
        "{f}{l}@{d}",  # johndoe@gmail.com
        "{fi}.{l}@{d}",  # j.doe@gmail.com
        "{f}{li}@{d}",  # johnd@gmail.com
        "{f}_{l}@{d}",  # john_doe@gmail.com
        "{f}.{l}2023@{d}",  # john.doe2023@gmail.com
        "{f}{l}123@{d}",  # johndoe123@gmail.com
    ]

    while retries < max_retries:
        try:
            # Generate name data
            first_name = fake.first_name()
            last_name = fake.last_name()

            # Generate email based on name
            domain = random.choice(domains)  # noqa: S311
            pattern = random.choice(email_patterns)  # noqa: S311

            email = pattern.format(
                f=first_name.lower(),
                l=last_name.lower(),
                fi=first_name[0].lower(),
                li=last_name[0].lower(),
                d=domain,
            )

            user_data = {
                "email": email,
                "first_name": first_name,
                "last_name": last_name,
                "password": "Password123!",  # Default password for test users
                "role": RoleType.admin if is_admin else RoleType.user,
            }

            await UserManager.register(user_data, session)

            user_type = "admin" if is_admin else "regular user"
            rprint(f"  Created {user_type}: {user_data['email']}")

        except HTTPException as exc:  # noqa: PERF203
            # If it's a duplicate email error, retry with a new email
            if exc.detail == ErrorMessages.EMAIL_EXISTS:
                retries += 1
                if retries < max_retries:
                    rprint(
                        "  [yellow]Email already exists, retrying... "
                        f"({retries}/{max_retries})"
                    )
                else:
                    rprint(
                        "  [red]Failed to create user after "
                        f"{max_retries} attempts"
                    )
                    return False
            else:
                # For other HTTP exceptions, raise them
                rprint(f"\n[red]-> ERROR adding user: [bold]{exc.detail}\n")
                return False

        except SQLAlchemyError as exc:
            rprint(f"\n[red]-> Database error adding user: [bold]{exc}\n")
            return False
        else:
            return True

    # we should never reach this point but it simplifies typing
    return False  # pragma: no cover


async def _populate_db(num_regular_users: int, num_admins: int) -> None:
    """Populate the database with random users."""
    # Initialize Faker
    fake = Faker()

    try:
        async with async_session() as session:
            # Create admin users
            admin_count = 0
            for _ in range(num_admins):
                success = await _create_single_user(
                    fake, session, is_admin=True
                )
                if success:
                    admin_count += 1

            # Create regular users
            user_count = 0
            for _ in range(num_regular_users):
                success = await _create_single_user(
                    fake, session, is_admin=False
                )
                if success:
                    user_count += 1

            await session.commit()

            # Final summary
            rprint(
                f"\nSuccessfully created {user_count} regular users "
                f"and {admin_count} admins"
            )

    except SQLAlchemyError as exc:
        rprint(f"\n[red]-> Database error: [bold]{exc}\n")
        raise typer.Exit(1) from exc


@app.command()
def seed(
    csv_file: Annotated[
        Path,
        typer.Argument(
            ...,
            file_okay=True,
            dir_okay=False,
            readable=True,
            help="Path to the CSV file containing user data",
        ),
    ] = Path("users.seed"),
    force: Optional[bool] = typer.Option(
        False,
        "--force",
        "-f",
        help="Do not ask for confirmation before importing users",
    ),
) -> None:
    """Seed the database with users from a CSV file.

    The CSV file should have a header row with the following columns:
    email,password,first_name,last_name,role

    The role column should contain either 'user' or 'admin'.
    If the role column is empty or invalid, 'user' will be used as the default.

    If no CSV file is specified, the command will look for 'users.seed' in the
    current directory.
    """
    # Check if the file exists
    if not csv_file.exists():
        rprint(f"[red]Error: File '{csv_file}' does not exist")
        raise typer.Exit(1)

    # Display which file we're using
    rprint(f"Using seed file: [green]{csv_file}")

    if not force:
        confirm = typer.confirm(
            "This will add new users to the database. Continue?",
            default=False,
        )
        if not confirm:
            rprint("[cyan]Operation Cancelled.")
            raise typer.Exit(0)

    rprint("\nImporting users from CSV file ... ")

    # Run the async function to import users
    aiorun(_seed_users_from_csv(csv_file))

    rprint(DONE_MSG)


def _validate_csv_file(csv_file: Path) -> list[dict[str, str]]:
    """Validate CSV file and return rows if valid."""
    with csv_file.open(encoding="utf-8") as file:
        csv_reader = csv.DictReader(file)

        # Check if fieldnames is None
        if csv_reader.fieldnames is None:
            rprint("[red]Error: CSV file has no header row")
            raise typer.Exit(1)

        # Check if required fields are present in the CSV
        required_fields = [
            "email",
            "password",
            "first_name",
            "last_name",
        ]
        if not all(field in csv_reader.fieldnames for field in required_fields):
            rprint(
                "[red]Error: CSV file must contain the following "
                "columns: "
                f"{', '.join(required_fields)}"
            )
            raise typer.Exit(1)

        # Convert to list to avoid reading the file twice
        return list(csv_reader)


async def _seed_users_from_csv(csv_file: Path) -> None:
    """Import users from a CSV file into the database."""
    try:
        # Validate the CSV file and get rows
        rows = _validate_csv_file(csv_file)

        success_count = 0
        error_count = 0
        duplicate_count = 0

        # Process each user in its own transaction
        for row in rows:
            # Create a new session for each user to prevent transaction issues
            async with async_session() as session:
                try:
                    # Prepare user data
                    user_data: dict[str, str | RoleType] = {
                        "email": row["email"].strip(),
                        "password": row["password"].strip(),
                        "first_name": row["first_name"].strip(),
                        "last_name": row["last_name"].strip(),
                    }

                    # Handle role (default to 'user' if not specified or
                    # invalid)
                    role = row.get("role", "").strip().lower()
                    if role == "admin":
                        user_data["role"] = RoleType.admin
                    else:
                        user_data["role"] = RoleType.user

                    # Register the user
                    await UserManager.register(user_data, session)
                    await session.commit()

                    rprint(f"  Created user: [green]{user_data['email']}")
                    success_count += 1

                except HTTPException as exc:
                    # Check for duplicate email error specifically
                    if exc.detail == ErrorMessages.EMAIL_EXISTS:
                        rprint(
                            f"  [yellow]Skipped: {user_data['email']} "
                            "(already exists)"
                        )
                        duplicate_count += 1
                    else:
                        rprint(
                            f"  [yellow]Failed: {user_data['email']} - "
                            f"{exc.detail}"
                        )
                        error_count += 1
                    # Rollback this transaction
                    await session.rollback()

                except (ValueError, KeyError) as e:
                    # Handle validation errors
                    rprint(
                        f"  [yellow]Failed: {row.get('email', 'unknown')} - "
                        f"{e!r}"
                    )
                    error_count += 1
                    await session.rollback()

                except SQLAlchemyError as e:
                    # Handle database errors with a cleaner message
                    error_msg = str(e).split("\n")[0]  # Just get the first line
                    rprint(
                        f"  [yellow]Database error: "
                        f"{row.get('email', 'unknown')} - {error_msg}"
                    )
                    error_count += 1
                    await session.rollback()

        # Final summary with more detailed information
        rprint(
            f"\nSummary: {success_count} users created, "
            f"{duplicate_count} duplicates skipped, "
            f"{error_count} errors\n"
        )

    except SQLAlchemyError as exc:
        rprint(f"\n[red]-> Database error: [bold]{exc}\n")
        raise typer.Exit(1) from exc
    except Exception as exc:
        rprint(f"\n[red]-> Error processing CSV file: [bold]{exc}\n")
        raise typer.Exit(1) from exc
